"""
R KIDS Ministry Management System - Flask Backend API
Clean and simple API structure with Supabase integration
"""

from flask import Flask, request, jsonify
from flask_cors import CORS
from datetime import datetime, timedelta
import os
import secrets
import json
from functools import wraps
from config import Config
from utils.audit_logger import log_activity, extract_ip_address, extract_user_agent, get_user_from_token

app = Flask(__name__)
# Allow all origins for CORS (http and https)
# Note: When using wildcard origins, credentials cannot be used
CORS(app, 
     resources={r"/api/*": {
         "origins": "*",  # Allow all HTTP and HTTPS origins
         "methods": ["GET", "POST", "PUT", "DELETE", "OPTIONS", "PATCH"],
         "allow_headers": ["Content-Type", "Authorization"],
         "supports_credentials": False  # Must be False when using wildcard origins
     }},
     allow_headers=["Content-Type", "Authorization"],
     expose_headers=["Content-Type", "Authorization"],
     max_age=3600)  # Cache preflight requests for 1 hour

# Load configuration
app.config.from_object(Config)

# Initialize Supabase client (using REST API instead of direct PostgreSQL)
try:
    from supabase_client import init_supabase, test_supabase_connection
    supabase_client = init_supabase()
    if supabase_client:
        print("‚úÖ Supabase client initialized (using REST API)")
        SUPABASE_AVAILABLE = True
    else:
        print("‚ö†Ô∏è Supabase client initialization failed - using in-memory storage")
        SUPABASE_AVAILABLE = False
except ImportError:
    print("‚ö†Ô∏è supabase-py not installed. Install with: pip install supabase")
    print("   Using in-memory storage for development")
    SUPABASE_AVAILABLE = False
except Exception as e:
    print(f"‚ö†Ô∏è Supabase initialization error: {e}")
    print("   Using in-memory storage for development")
    SUPABASE_AVAILABLE = False

# Try to initialize direct PostgreSQL database (optional - fallback)
try:
    from database import db, init_db
    from models import User, Church, Group, Guardian, Child
    init_db(app)
    print("‚úÖ Direct PostgreSQL database initialized (optional)")
    DB_AVAILABLE = True
except Exception as e:
    print(f"‚ö†Ô∏è Direct PostgreSQL connection skipped: {e}")
    DB_AVAILABLE = False

# Fallback in-memory storage (for development/testing)
users_db = {}
children_db = {}
parents_db = {}
guardians_db = {}
attendance_db = {}
notifications_db = {}
mfa_codes_db = {}  # Store temporary MFA codes: {token: {'code': '123456', 'expires_at': datetime}}

# Seed default admin users
def seed_admin_users():
    """Create default admin user for development"""
    admin_email = 'admin@rkids.church'
    admin_password = 'password123'
    
    # Store admin user in in-memory database
    admin_token = f"token_{admin_email}_{datetime.now().timestamp()}"
    users_db[admin_token] = {
        'id': 'admin_1',
        'email': admin_email,
        'role': 'admin',
        'name': 'Admin User'
    }
    
    print("\n‚úÖ Admin user created:")
    print(f"   üìß Email: {admin_email}")
    print(f"   üîë Password: {admin_password}")
    print("   ‚ö†Ô∏è  OTP code will be generated by backend on login\n")

# Seed admin user on startup
seed_admin_users()

# Helper: Get auth token from header
def get_token():
    auth_header = request.headers.get('Authorization', '')
    if auth_header.startswith('Bearer '):
        return auth_header.split(' ')[1]
    return None

# Helper: Get or create default church
def get_default_church_id():
    """Get or create default church for single-tenant setup"""
    if not SUPABASE_AVAILABLE or not supabase_client:
        return None
    
    try:
        # Try to get existing church
        result = supabase_client.table('churches').select('church_id').limit(1).execute()
        if result.data and len(result.data) > 0:
            return result.data[0]['church_id']
        
        # Create default church if none exists
        church_data = {
            'name': 'Ruach South Assembly',
            'location': 'Growth Happens Here',
            'settings': {}
        }
        result = supabase_client.table('churches').insert(church_data).execute()
        if result.data and len(result.data) > 0:
            church_id = result.data[0]['church_id']
            print(f"‚úÖ Created default church: {church_id}")
            return church_id
    except Exception as e:
        print(f"‚ö†Ô∏è Error getting/creating church: {e}")
        import traceback
        traceback.print_exc()
    
    return None

# Helper: Verify token (simplified for development)
def verify_token(token):
    # In production, verify JWT token
    # For now, check both in-memory and Supabase
    if token and token in users_db:
        return True
    
    # Could also verify against Supabase if needed
    return False

# Decorator: Require authentication
def require_auth(f):
    @wraps(f)
    def decorated_function(*args, **kwargs):
        # Allow OPTIONS requests for CORS preflight
        if request.method == 'OPTIONS':
            return jsonify({'status': 'ok'}), 200
        token = get_token()
        if not token or not verify_token(token):
            return jsonify({'error': 'Unauthorized'}), 401
        return f(*args, **kwargs)
    return decorated_function

# ============================================================================
# AUTHENTICATION ENDPOINTS
# ============================================================================

@app.route('/api/auth/login', methods=['POST'])
def login():
    """Login endpoint"""
    data = request.get_json()
    email = data.get('email', '').lower()
    password = data.get('password', '')
    
    # Check if user exists and needs to set password
    users_by_email = globals().get('users_by_email', {})
    if email in users_by_email:
        user_id = users_by_email[email]
        user = users_db.get(user_id)
        if user and not user.get('password_set', False):
            # User needs to set password first
            return jsonify({
                'error': 'Password not set',
                'requires_password_setup': True,
                'email': email
            }), 403
    
    # Simple validation (replace with database check)
    # For now, allow default password for existing users
    if email and password == 'password123':
        # Generate token (simplified)
        token = f"token_{email}_{datetime.now().timestamp()}"
        
        # Extract role from email (admin@, teacher@, parent@, teen@)
        role_map = {
            'admin': 'admin',
            'teacher': 'teacher',
            'parent': 'parent',
            'teen': 'teen'
        }
        role = 'parent'  # default
        for key, value in role_map.items():
            if email.startswith(key + '@'):
                role = value
                break
        
        # Check if user already exists in users_db
        existing_user = None
        for u in users_db.values():
            if u.get('email') == email:
                existing_user = u
                break
        
        if existing_user:
            user = existing_user
            # Update token association
            users_db[token] = user
        else:
            user = {
                'id': email.split('@')[0] + '_id',
                'email': email,
                'role': role,
                'name': email.split('@')[0].title() + ' User',
                'profile_updated': False,  # New users need to update profile
                'status': 'active'
            }
            users_db[token] = user
        
        # Ensure profile_updated field exists
        if 'profile_updated' not in user:
            user['profile_updated'] = False
        
        # Generate 6-digit OTP code
        otp_code = ''.join([str(secrets.randbelow(10)) for _ in range(6)])
        expires_at = datetime.now() + timedelta(minutes=10)  # OTP expires in 10 minutes
        
        # Store OTP code with expiration
        mfa_codes_db[token] = {
            'code': otp_code,
            'expires_at': expires_at
        }
        
        print(f"üîê Generated OTP for {email}: {otp_code} (expires at {expires_at.strftime('%H:%M:%S')})")
        
        # Log login attempt (before MFA verification)
        if SUPABASE_AVAILABLE and supabase_client:
            church_id = get_default_church_id()
            user_id_for_log = existing_user.get('id') if existing_user else None
            if church_id:
                log_activity(
                    supabase_client=supabase_client,
                    church_id=church_id,
                    user_id=user_id_for_log,
                    action_performed='LOGIN_ATTEMPT',
                    entity_type='user',
                    entity_id=user_id_for_log,
                    details={'email': email, 'status': 'pending_mfa'},
                    ip_address=extract_ip_address(request),
                    user_agent=extract_user_agent(request)
                )
        
        return jsonify({
            'data': {
                'token': token,
                'requiresMFA': True,
                'otpCode': otp_code  # Send OTP to frontend (in production, send via SMS/Email)
            }
        })
    
    return jsonify({'error': 'Invalid credentials'}), 401

@app.route('/api/auth/verify-mfa', methods=['POST'])
def verify_mfa():
    """Verify MFA code"""
    data = request.get_json()
    code = data.get('code', '')
    token = data.get('token')
    
    # Get token from Authorization header if not in body
    if not token:
        auth_header = request.headers.get('Authorization', '')
        if auth_header.startswith('Bearer '):
            token = auth_header.split(' ')[1]
    
    # Verify token exists
    if not token or token not in users_db:
        return jsonify({'error': 'Invalid or expired session'}), 401
    
    # Check if OTP code exists for this token
    if token not in mfa_codes_db:
        return jsonify({'error': 'MFA code expired. Please login again.'}), 401
    
    mfa_data = mfa_codes_db[token]
    
    # Check if OTP expired
    if datetime.now() > mfa_data['expires_at']:
        del mfa_codes_db[token]
        return jsonify({'error': 'MFA code expired. Please login again.'}), 401
    
    # Verify OTP code
    if code == mfa_data['code']:
        user = users_db[token]
        # Clean up OTP code after successful verification
        del mfa_codes_db[token]
        
        # Ensure profile_updated field exists
        if 'profile_updated' not in user:
            user['profile_updated'] = False
        
        # Log successful login
        if SUPABASE_AVAILABLE and supabase_client:
            church_id = get_default_church_id()
            user_id_for_log = user.get('id') or user.get('user_id')
            if church_id:
                log_activity(
                    supabase_client=supabase_client,
                    church_id=church_id,
                    user_id=user_id_for_log,
                    action_performed='LOGIN',
                    entity_type='user',
                    entity_id=user_id_for_log,
                    details={'email': user.get('email'), 'role': user.get('role')},
                    ip_address=extract_ip_address(request),
                    user_agent=extract_user_agent(request)
                )
        
        return jsonify({
            'data': {
                'token': token,
                'user': user
            }
        })
    
    return jsonify({'error': 'Invalid verification code'}), 401

@app.route('/api/auth/logout', methods=['POST'])
@require_auth
def logout():
    """Logout endpoint"""
    token = get_token()
    if token in users_db:
        del users_db[token]
    return jsonify({'data': {'success': True}})

# ============================================================================
# PARENTS ENDPOINTS
# ============================================================================

@app.route('/api/parents', methods=['GET'])
@require_auth
def list_parents():
    """List all parents"""
    return jsonify({'data': list(parents_db.values())})

@app.route('/api/parents', methods=['POST'])
@require_auth
def create_parent():
    """Create new parent"""
    data = request.get_json()
    parent_id = f"parent_{len(parents_db) + 1}"
    parent = {
        'id': parent_id,
        'name': data.get('name', ''),
        'email': data.get('email', ''),
        'childrenCount': 0,
        'status': 'active'
    }
    parents_db[parent_id] = parent
    return jsonify({'data': parent}), 201

@app.route('/api/parents/<parent_id>', methods=['GET'])
@require_auth
def get_parent(parent_id):
    """Get parent by ID"""
    if parent_id in parents_db:
        return jsonify({'data': parents_db[parent_id]})
    return jsonify({'error': 'Parent not found'}), 404

# ============================================================================
# CHILDREN ENDPOINTS
# ============================================================================

@app.route('/api/children', methods=['GET'])
@require_auth
def list_children():
    """List children with optional filters"""
    parent_id = request.args.get('parent_id')
    group = request.args.get('group')
    
    children = list(children_db.values())
    
    if parent_id:
        children = [c for c in children if c.get('parentId') == parent_id]
    if group:
        children = [c for c in children if c.get('group') == group]
    
    return jsonify({'data': children})

@app.route('/api/children', methods=['POST'])
@require_auth
def create_child():
    """Create new child (pending approval)"""
    data = request.get_json()
    child_id = f"child_{len(children_db) + 1}"
    child = {
        'id': child_id,
        'registrationId': '',
        'name': data.get('name', ''),
        'age': data.get('age', 0),
        'dateOfBirth': data.get('dateOfBirth', ''),
        'group': data.get('group', ''),
        'parentId': data.get('parentId', ''),
        'status': 'pending',
        'gender': data.get('gender', ''),
        'guardians': [],
        'submittedBy': 'parent',
        'submittedAt': datetime.now().isoformat()
    }
    children_db[child_id] = child
    
    # Log child creation
    if SUPABASE_AVAILABLE and supabase_client:
        church_id = get_default_church_id()
        token = get_token()
        creator_user = get_user_from_token(users_db, token) if token else None
        creator_id = creator_user.get('id') or creator_user.get('user_id') if creator_user else None
        
        if church_id:
            log_activity(
                supabase_client=supabase_client,
                church_id=church_id,
                user_id=creator_id,
                action_performed='CREATE_CHILD',
                entity_type='child',
                entity_id=child_id,
                details={
                    'child_name': child.get('name'),
                    'parent_id': child.get('parentId'),
                    'group': child.get('group'),
                    'status': 'pending'
                },
                ip_address=extract_ip_address(request),
                user_agent=extract_user_agent(request)
            )
    
    return jsonify({'data': child}), 201

@app.route('/api/children/pending', methods=['GET'])
@require_auth
def get_pending_children():
    """Get pending children for approval"""
    pending = [c for c in children_db.values() if c.get('status') == 'pending']
    return jsonify({'data': pending})

@app.route('/api/children/<child_id>/approve', methods=['POST'])
@require_auth
def approve_child(child_id):
    """Approve child"""
    if child_id in children_db:
        child = children_db[child_id]
        child['status'] = 'active'
        child['registrationId'] = f"RS{child['parentId'].split('_')[1] if '_' in child['parentId'] else '000'}/{len([c for c in children_db.values() if c.get('parentId') == child['parentId']])}"
        
        # Log child approval
        if SUPABASE_AVAILABLE and supabase_client:
            church_id = get_default_church_id()
            token = get_token()
            admin_user = get_user_from_token(users_db, token) if token else None
            admin_id = admin_user.get('id') or admin_user.get('user_id') if admin_user else None
            
            if church_id:
                log_activity(
                    supabase_client=supabase_client,
                    church_id=church_id,
                    user_id=admin_id,
                    action_performed='APPROVE_CHILD',
                    entity_type='child',
                    entity_id=child_id,
                    details={
                        'child_name': child.get('name'),
                        'registration_id': child.get('registrationId'),
                        'parent_id': child.get('parentId')
                    },
                    ip_address=extract_ip_address(request),
                    user_agent=extract_user_agent(request)
                )
        
        return jsonify({'data': child})
    return jsonify({'error': 'Child not found'}), 404

@app.route('/api/children/<child_id>/reject', methods=['POST'])
@require_auth
def reject_child(child_id):
    """Reject child"""
    data = request.get_json()
    if child_id in children_db:
        child = children_db[child_id]
        child['status'] = 'rejected'
        child['rejectionReason'] = data.get('reason', '')
        
        # Log child rejection
        if SUPABASE_AVAILABLE and supabase_client:
            church_id = get_default_church_id()
            token = get_token()
            admin_user = get_user_from_token(users_db, token) if token else None
            admin_id = admin_user.get('id') or admin_user.get('user_id') if admin_user else None
            
            if church_id:
                log_activity(
                    supabase_client=supabase_client,
                    church_id=church_id,
                    user_id=admin_id,
                    action_performed='REJECT_CHILD',
                    entity_type='child',
                    entity_id=child_id,
                    details={
                        'child_name': child.get('name'),
                        'rejection_reason': data.get('reason', ''),
                        'parent_id': child.get('parentId')
                    },
                    ip_address=extract_ip_address(request),
                    user_agent=extract_user_agent(request)
                )
        
        return jsonify({'data': child})
    return jsonify({'error': 'Child not found'}), 404

# ============================================================================
# CHECK-IN ENDPOINTS
# ============================================================================

@app.route('/api/checkin/generate-qr', methods=['POST'])
@require_auth
def generate_checkin_qr():
    """Generate check-in QR code"""
    data = request.get_json()
    child_id = data.get('child_id')
    
    qr_data = {
        'type': 'checkin',
        'child_id': child_id,
        'timestamp': datetime.now().isoformat(),
        'expires_at': (datetime.now() + timedelta(minutes=15)).isoformat()
    }
    
    import json
    qr_code = json.dumps(qr_data)
    
    return jsonify({
        'data': {
            'qr_code': qr_code,
            'expires_at': qr_data['expires_at']
        }
    })

@app.route('/api/checkin/scan-qr', methods=['POST'])
@require_auth
def scan_checkin_qr():
    """Scan and process QR code for check-in"""
    data = request.get_json()
    qr_data = data.get('qr_data')
    
    import json
    try:
        qr_info = json.loads(qr_data)
        child_id = qr_info.get('child_id')
        
        if child_id in children_db:
            child = children_db[child_id]
            return jsonify({
                'data': {
                    'child': child,
                    'guardians': child.get('guardians', [])
                }
            })
    except:
        pass
    
    return jsonify({'error': 'Invalid QR code'}), 400

# ============================================================================
# CHECK-OUT ENDPOINTS
# ============================================================================

@app.route('/api/checkout/notify/<child_id>', methods=['POST'])
@require_auth
def send_pickup_notification(child_id):
    """Send pickup notification"""
    if child_id in children_db:
        import secrets
        otp = ''.join([str(secrets.randbelow(10)) for _ in range(6)])
        
        notification = {
            'id': f"notif_{len(notifications_db) + 1}",
            'type': 'pickup',
            'title': 'Child Ready for Pickup',
            'message': f"{children_db[child_id]['name']} is ready to be picked up",
            'read': False,
            'createdAt': datetime.now().isoformat(),
            'metadata': {'child_id': child_id, 'otp': otp}
        }
        notifications_db[notification['id']] = notification
        
        return jsonify({
            'data': {
                'teacher_qr': f"pickup_{child_id}",
                'parent_qr': f"pickup_{child_id}_parent",
                'otp': otp,
                'expires_at': (datetime.now() + timedelta(minutes=30)).isoformat()
            }
        })
    return jsonify({'error': 'Child not found'}), 404

# ============================================================================
# NOTIFICATIONS ENDPOINTS
# ============================================================================

@app.route('/api/notifications', methods=['GET'])
@require_auth
def list_notifications():
    """List notifications"""
    return jsonify({'data': list(notifications_db.values())})

@app.route('/api/notifications/unread-count', methods=['GET'])
@require_auth
def get_unread_count():
    """Get unread notification count"""
    unread = len([n for n in notifications_db.values() if not n.get('read', False)])
    return jsonify({'data': {'count': unread}})

# ============================================================================
# GROUPS ENDPOINTS
# ============================================================================

@app.route('/api/groups', methods=['GET'])
@require_auth
def list_groups():
    """List all groups"""
    from utils.db_helpers import get_groups
    
    try:
        # Try to get groups from Supabase
        groups = get_groups()
        if groups:
            group_names = [g.name for g in groups]
            return jsonify({'data': group_names})
    except Exception as e:
        print(f"Error fetching groups from database: {e}")
    
    # Fallback to default groups
    return jsonify({
        'data': ['Little Angels', 'Saints', 'Disciples', 'Trendsetters']
    })

@app.route('/api/groups/<group_name>', methods=['PUT'])
@require_auth
def update_group(group_name):
    """Update group (e.g., assign teacher)"""
    from utils.db_helpers import get_group_by_name
    
    try:
        data = request.get_json()
        group = get_group_by_name(group_name)
        
        if not group:
            return jsonify({'error': 'Group not found'}), 404
        
        if 'teacher_id' in data:
            group.teacher_id = data['teacher_id'] if data['teacher_id'] else None
            try:
                from database import db
                db.session.commit()
            except:
                pass
        
        return jsonify({'data': group.to_dict()})
    except Exception as e:
        print(f"Error updating group: {e}")
        try:
            from database import db
            db.session.rollback()
        except:
            pass
        return jsonify({'error': 'Failed to update group'}), 500

# ============================================================================
# USERS ENDPOINTS
# ============================================================================

@app.route('/api/users', methods=['GET'])
@require_auth
def list_users():
    """List users, optionally filtered by role"""
    role = request.args.get('role')
    
    users_list = []
    
    # Try to fetch from Supabase first
    if SUPABASE_AVAILABLE and supabase_client:
        try:
            church_id = get_default_church_id()
            if church_id:
                query = supabase_client.table('users').select('*').eq('church_id', church_id)
                
                if role:
                    # Capitalize role to match database format
                    role_capitalized = role.capitalize()
                    query = query.eq('role', role_capitalized)
                
                result = query.execute()
                
                if result.data:
                    for db_user in result.data:
                        user_dict = {
                            'id': str(db_user['user_id']),
                            'user_id': str(db_user['user_id']),
                            'email': db_user['email'],
                            'role': db_user['role'].lower(),
                            'name': db_user.get('name') or db_user['email'].split('@')[0].title(),
                            'status': db_user.get('status') or ('active' if db_user.get('is_active', True) else 'suspended'),
                            'profile_updated': db_user.get('profile_updated', False),
                            'phone': db_user.get('phone'),
                            'address': db_user.get('address'),
                            'created_at': db_user.get('created_at', datetime.now().isoformat()),
                            'updated_at': db_user.get('updated_at', datetime.now().isoformat()),
                        }
                        users_list.append(user_dict)
        except Exception as e:
            print(f"‚ö†Ô∏è Error fetching users from Supabase: {e}")
            # Fall through to in-memory storage
    
    # Fallback to in-memory storage
    if not users_list:
        try:
            from utils.db_helpers import get_users_by_role
            if role:
                users = get_users_by_role(role)
            else:
                try:
                    from models import User
                    if User:
                        users = User.query.all()
                    else:
                        users = []
                except:
                    users = []
            
            if users:
                users_list = [u.to_dict() if hasattr(u, 'to_dict') else u for u in users]
        except Exception as e:
            print(f"Error fetching users from database: {e}")
        
        # Also check in-memory storage
        if not users_list:
            for user in users_db.values():
                if not role or user.get('role', '').lower() == role.lower():
                    users_list.append(user)
    
    return jsonify({'data': users_list})

@app.route('/api/users', methods=['POST'])
@require_auth
def create_user():
    """Create new user and send invitation"""
    data = request.get_json()
    email = data.get('email', '').lower()
    name = data.get('name', '')
    role = data.get('role', '').lower()
    send_email = data.get('sendEmail', True)
    custom_email_message = data.get('customEmailMessage', '')
    
    # Generate temporary password/token for invitation
    import secrets
    from werkzeug.security import generate_password_hash
    invitation_token = secrets.token_urlsafe(32)
    
    # Generate a temporary password hash (user will set their own password)
    temp_password_hash = generate_password_hash(invitation_token)
    
    # Capitalize role for database (Admin, Teacher, Parent, Teen)
    role_capitalized = role.capitalize() if role else 'Parent'
    
    user_data = {
        'email': email,
        'name': name,
        'role': role_capitalized,
        'status': 'pending_password',
        'password_set': False,
        'profile_updated': False,
        'phone': None,
        'address': None,
        'invitation_token': invitation_token,
        'invitation_sent_at': datetime.now().isoformat(),
    }
    
    # Try to save to Supabase first
    if SUPABASE_AVAILABLE and supabase_client:
        try:
            church_id = get_default_church_id()
            if not church_id:
                raise Exception("Could not get or create default church")
            
            # Check if user already exists
            existing = supabase_client.table('users').select('user_id, email').eq('email', email).eq('church_id', church_id).execute()
            if existing.data and len(existing.data) > 0:
                return jsonify({'error': 'User with this email already exists'}), 400
            
            # Insert user into Supabase
            # Start with required fields
            supabase_user = {
                'church_id': church_id,
                'email': email,
                'password_hash': temp_password_hash,
                'role': role_capitalized,
                'is_active': True,
            }
            
            # Add optional fields if columns exist (they may not if migration hasn't run)
            # We'll try to add them, but Supabase will ignore if columns don't exist
            try:
                supabase_user['name'] = name
                supabase_user['status'] = 'pending_password'
                supabase_user['password_set'] = False
                supabase_user['profile_updated'] = False
                supabase_user['invitation_token'] = invitation_token
                supabase_user['invitation_sent_at'] = datetime.now().isoformat()
            except:
                # If these fields cause issues, we'll insert without them
                pass
            
            result = supabase_client.table('users').insert(supabase_user).execute()
            
            if result.data and len(result.data) > 0:
                db_user = result.data[0]
                user_data['id'] = str(db_user['user_id'])
                user_data['user_id'] = str(db_user['user_id'])
                print(f"‚úÖ User saved to Supabase: {email} (ID: {db_user['user_id']})")
                
                # Log user creation
                token = get_token()
                creator_user = get_user_from_token(users_db, token) if token else None
                creator_id = creator_user.get('id') or creator_user.get('user_id') if creator_user else None
                
                log_activity(
                    supabase_client=supabase_client,
                    church_id=church_id,
                    user_id=creator_id,
                    action_performed='CREATE_USER',
                    entity_type='user',
                    entity_id=str(db_user['user_id']),
                    details={
                        'created_user_email': email,
                        'created_user_role': role_capitalized,
                        'created_user_name': name,
                        'invitation_sent': send_email
                    },
                    ip_address=extract_ip_address(request),
                    user_agent=extract_user_agent(request)
                )
            else:
                raise Exception("Failed to insert user into Supabase")
                
        except Exception as e:
            print(f"‚ö†Ô∏è Error saving to Supabase: {e}")
            print("   Falling back to in-memory storage")
            # Fall through to in-memory storage
    
    # Fallback to in-memory storage if Supabase not available or failed
    if 'id' not in user_data:
        user_id = f"{role.lower()}_{len(users_db) + 1}"
        user_data['id'] = user_id
        user_data['user_id'] = user_id
        users_db[user_id] = user_data
        
        # Store user by email for lookup
        if 'users_by_email' not in globals():
            globals()['users_by_email'] = {}
        globals()['users_by_email'][email] = user_id
        print(f"‚úÖ User saved to in-memory storage: {email}")
    
    # Send email invitation if requested
    if send_email:
        email_message = custom_email_message if custom_email_message else f"Welcome to R-KIDS Ministry! Please set your password using this link: {invitation_token}"
        # In production, send email invitation here using SendGrid
        print(f"üìß Invitation email sent to {email}")
        print(f"   Message: {email_message}")
    else:
        print(f"‚úÖ User created: {email} (no email sent)")
    
    print(f"   User must set password before first login")
    
    return jsonify({'data': user_data}), 201

@app.route('/api/users/resend-invitation', methods=['POST'])
@require_auth
def resend_invitation():
    """Resend invitation to user"""
    data = request.get_json()
    email = data.get('email', '').lower()
    
    # Find user by email
    user = None
    for u in users_db.values():
        if u.get('email') == email:
            user = u
            break
    
    if not user:
        return jsonify({'error': 'User not found'}), 404
    
    # Generate new invitation token
    import secrets
    invitation_token = secrets.token_urlsafe(32)
    user['invitation_token'] = invitation_token
    user['invitation_sent_at'] = datetime.now().isoformat()
    
    # In production, send email invitation here
    print(f"üìß Invitation resent to {email} with token: {invitation_token}")
    
    return jsonify({'data': {'message': 'Invitation resent successfully'}})

@app.route('/api/users/<user_id>/suspend', methods=['POST'])
@require_auth
def suspend_user(user_id):
    """Suspend a user"""
    user = None
    for u in users_db.values():
        if u.get('id') == user_id:
            user = u
            break
    
    if not user:
        return jsonify({'error': 'User not found'}), 404
    
    user['status'] = 'suspended'
    user['updated_at'] = datetime.now().isoformat()
    
    # Log user suspension
    if SUPABASE_AVAILABLE and supabase_client:
        church_id = get_default_church_id()
        token = get_token()
        admin_user = get_user_from_token(users_db, token) if token else None
        admin_id = admin_user.get('id') or admin_user.get('user_id') if admin_user else None
        
        if church_id:
            log_activity(
                supabase_client=supabase_client,
                church_id=church_id,
                user_id=admin_id,
                action_performed='SUSPEND_USER',
                entity_type='user',
                entity_id=user_id,
                details={
                    'suspended_user_email': user.get('email'),
                    'suspended_user_name': user.get('name')
                },
                ip_address=extract_ip_address(request),
                user_agent=extract_user_agent(request)
            )
    
    print(f"üö´ User {user['email']} suspended")
    return jsonify({'data': user})

@app.route('/api/users/<user_id>/activate', methods=['POST'])
@require_auth
def activate_user(user_id):
    """Activate a suspended user"""
    user = None
    for u in users_db.values():
        if u.get('id') == user_id:
            user = u
            break
    
    if not user:
        return jsonify({'error': 'User not found'}), 404
    
    # If password is set, activate. Otherwise keep as pending_password
    if user.get('password_set', False):
        user['status'] = 'active'
    else:
        user['status'] = 'pending_password'
    
    user['updated_at'] = datetime.now().isoformat()
    
    # Log user activation
    if SUPABASE_AVAILABLE and supabase_client:
        church_id = get_default_church_id()
        token = get_token()
        admin_user = get_user_from_token(users_db, token) if token else None
        admin_id = admin_user.get('id') or admin_user.get('user_id') if admin_user else None
        
        if church_id:
            log_activity(
                supabase_client=supabase_client,
                church_id=church_id,
                user_id=admin_id,
                action_performed='ACTIVATE_USER',
                entity_type='user',
                entity_id=user_id,
                details={
                    'activated_user_email': user.get('email'),
                    'activated_user_name': user.get('name')
                },
                ip_address=extract_ip_address(request),
                user_agent=extract_user_agent(request)
            )
    
    print(f"‚úÖ User {user['email']} activated")
    return jsonify({'data': user})

@app.route('/api/users/profile', methods=['PUT'])
@require_auth
def update_profile():
    """Update user profile (name, phone, address)"""
    token = get_token()
    if not token:
        return jsonify({'error': 'Unauthorized'}), 401
    
    data = request.get_json()
    user = None
    
    # Try to get user from Supabase first
    if SUPABASE_AVAILABLE and supabase_client:
        try:
            # Get user email from token (simplified - in production, decode JWT)
            # For now, we'll need to get user from token mapping
            # This is a simplified approach - in production, decode JWT to get user_id
            if token in users_db:
                user_email = users_db[token].get('email')
            else:
                # Try to find user by token in Supabase (if we stored token mapping)
                # For now, fall back to in-memory
                user_email = None
            
            if user_email:
                church_id = get_default_church_id()
                if church_id:
                    # Find user by email
                    result = supabase_client.table('users').select('*').eq('email', user_email).eq('church_id', church_id).execute()
                    if result.data and len(result.data) > 0:
                        db_user = result.data[0]
                        user_id = db_user['user_id']
                        
                        # Update user in Supabase
                        update_data = {
                            'updated_at': datetime.now().isoformat(),
                            'profile_updated': True,
                        }
                        if 'name' in data:
                            update_data['name'] = data['name']
                        if 'phone' in data:
                            update_data['phone'] = data.get('phone') or None
                        if 'address' in data:
                            update_data['address'] = data.get('address') or None
                        
                        result = supabase_client.table('users').update(update_data).eq('user_id', user_id).execute()
                        
                        if result.data and len(result.data) > 0:
                            updated_user = result.data[0]
                            user = {
                                'id': str(updated_user['user_id']),
                                'email': updated_user['email'],
                                'role': updated_user['role'].lower(),
                                'name': updated_user.get('name'),
                                'phone': updated_user.get('phone'),
                                'address': updated_user.get('address'),
                                'profile_updated': updated_user.get('profile_updated', True),
                            }
                            print(f"‚úÖ Profile updated in Supabase for {user_email}")
        except Exception as e:
            print(f"‚ö†Ô∏è Error updating profile in Supabase: {e}")
            # Fall through to in-memory storage
    
    # Fallback to in-memory storage
    if not user and token in users_db:
        user = users_db[token]
        if 'name' in data:
            user['name'] = data['name']
        if 'phone' in data:
            user['phone'] = data.get('phone') or None
        if 'address' in data:
            user['address'] = data.get('address') or None
        user['profile_updated'] = True
        user['updated_at'] = datetime.now().isoformat()
        print(f"‚úÖ Profile updated in memory for {user.get('email')}")
    
    if not user:
        return jsonify({'error': 'User not found'}), 404
    
    return jsonify({'data': user})

# ============================================================================
# ATTENDANCE ENDPOINTS
# ============================================================================

@app.route('/api/attendance', methods=['GET', 'OPTIONS'])
@require_auth
def list_attendance():
    """List attendance records"""
    date = request.args.get('date')
    child_id = request.args.get('child_id')
    group = request.args.get('group')
    
    # Return empty list for now (will be populated from database)
    return jsonify({'data': []})

@app.route('/api/attendance/submit', methods=['POST', 'OPTIONS'])
@require_auth
def submit_attendance():
    """Submit attendance records"""
    data = request.get_json()
    return jsonify({'data': {'success': True}})

# ============================================================================
# REPORTS ENDPOINTS
# ============================================================================

@app.route('/api/reports/attendance', methods=['GET', 'OPTIONS'])
@require_auth
def get_attendance_report():
    """Get attendance reports"""
    period = request.args.get('period', 'daily')
    group = request.args.get('group')
    
    # Return empty report for now
    return jsonify({
        'data': {
            'period': period,
            'total_present': 0,
            'total_absent': 0,
            'attendance_rate': 0,
            'records': []
        }
    })

# ============================================================================
# AUDIT LOG ENDPOINTS
# ============================================================================

@app.route('/api/audit', methods=['GET', 'OPTIONS'])
@require_auth
def list_audit_logs():
    """List audit logs with filtering options"""
    action = request.args.get('action')
    user_id = request.args.get('user_id')
    date_from = request.args.get('date_from')
    date_to = request.args.get('date_to')
    
    logs_list = []
    
    # Try to fetch from Supabase
    if SUPABASE_AVAILABLE and supabase_client:
        try:
            church_id = get_default_church_id()
            if church_id:
                query = supabase_client.table('audit_logs').select('*').eq('church_id', church_id).limit(500)
                
                if action:
                    query = query.eq('action_performed', action)
                if user_id:
                    query = query.eq('user_id', user_id)
                if date_from:
                    query = query.gte('timestamp', date_from)
                if date_to:
                    query = query.lte('timestamp', date_to)
                
                result = query.execute()
                
                if result.data:
                    # Collect unique user IDs
                    user_ids = set()
                    for log in result.data:
                        if log.get('user_id'):
                            user_ids.add(log['user_id'])
                    
                    # Fetch user info for all users in one query
                    users_map = {}
                    if user_ids:
                        try:
                            users_result = supabase_client.table('users').select('user_id, email, name').in_('user_id', list(user_ids)).execute()
                            if users_result.data:
                                for user in users_result.data:
                                    users_map[str(user['user_id'])] = {
                                        'email': user.get('email', ''),
                                        'name': user.get('name', '')
                                    }
                        except Exception as e:
                            print(f"‚ö†Ô∏è Error fetching user info: {e}")
                    
                    for log in result.data:
                        # Get user info from map
                        log_user_id = str(log.get('user_id', '')) if log.get('user_id') else None
                        user_info = users_map.get(log_user_id, {}) if log_user_id else {}
                        user_name = user_info.get('name') or user_info.get('email', 'Unknown') if user_info else 'Unknown'
                        user_email = user_info.get('email', '') if user_info else ''
                        
                        # Parse details if it's a JSON string
                        details_str = log.get('details', '')
                        try:
                            if isinstance(details_str, str):
                                details = json.loads(details_str) if details_str else {}
                            else:
                                details = details_str or {}
                        except:
                            details = {}
                        
                        log_entry = {
                            'id': str(log['log_id']),
                            'timestamp': log.get('timestamp', ''),
                            'user': user_name,
                            'user_id': log_user_id,
                            'user_email': user_email,
                            'action': log.get('action_performed', ''),
                            'entity_type': log.get('entity_type'),
                            'entity_id': log.get('entity_id'),
                            'details': details,
                            'ip': log.get('ip_address'),
                            'user_agent': log.get('user_agent'),
                        }
                        logs_list.append(log_entry)
                    
                    # Sort by timestamp descending (most recent first)
                    logs_list.sort(key=lambda x: x.get('timestamp', ''), reverse=True)
                        
        except Exception as e:
            print(f"‚ö†Ô∏è Error fetching audit logs from Supabase: {e}")
            import traceback
            traceback.print_exc()
    
    return jsonify({'data': logs_list})

# ============================================================================
# CORS PREFLIGHT HANDLER
# ============================================================================

@app.after_request
def after_request(response):
    """Add CORS headers to all responses"""
    response.headers.add("Access-Control-Allow-Origin", "*")
    response.headers.add('Access-Control-Allow-Headers', "Content-Type,Authorization")
    response.headers.add('Access-Control-Allow-Methods', "GET,PUT,POST,DELETE,OPTIONS,PATCH")
    response.headers.add('Access-Control-Max-Age', "3600")
    return response

# ============================================================================
# HEALTH CHECK
# ============================================================================

@app.route('/api/health', methods=['GET'])
def health():
    """Health check endpoint with detailed Supabase connection info"""
    from supabase_client import test_supabase_connection, get_supabase
    
    health_info = {
        'status': 'ok',
        'timestamp': datetime.now().isoformat()
    }
    
    # Check Supabase REST API connection
    supabase_status = 'connected' if test_supabase_connection() else 'disconnected'
    health_info['supabase_api'] = supabase_status
    
    # Get detailed Supabase info if connected
    if supabase_status == 'connected':
        try:
            client = get_supabase()
            if client:
                # Try to get church count
                try:
                    result = client.table('churches').select('count', count='exact').limit(1).execute()
                    health_info['supabase_tables_accessible'] = True
                    health_info['churches_count'] = result.count if hasattr(result, 'count') else 'N/A'
                except:
                    health_info['supabase_tables_accessible'] = False
                    health_info['note'] = 'Connection works but tables may not exist'
        except Exception as e:
            health_info['supabase_error'] = str(e)
    
    # Check direct PostgreSQL connection (optional)
    try:
        from utils.db_helpers import test_db_connection
        db_status = 'connected' if test_db_connection() else 'disconnected'
        health_info['postgresql'] = db_status  # Direct PostgreSQL connection (optional)
    except:
        health_info['postgresql'] = 'not_configured'
    
    return jsonify(health_info)

# ============================================================================
# ERROR HANDLERS
# ============================================================================

@app.errorhandler(404)
def not_found(error):
    return jsonify({'error': 'Not found'}), 404

@app.errorhandler(500)
def internal_error(error):
    return jsonify({'error': 'Internal server error'}), 500

# ============================================================================
# RUN APPLICATION
# ============================================================================

if __name__ == '__main__':
    port = int(os.environ.get('PORT', 5000))
    # Only run in debug mode if not in production
    debug = os.environ.get('FLASK_ENV') != 'production'
    app.run(host='0.0.0.0', port=port, debug=debug)
